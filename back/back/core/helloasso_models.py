import enum
import hashlib
import hmac
import json
import time
from base64 import urlsafe_b64encode, urlsafe_b64decode
from datetime import datetime
from enum import Enum
from typing import Annotated, Literal
from motor.motor_asyncio import AsyncIOMotorDatabase
from common_models.base import RezelBaseModel
from pydantic import ConfigDict, Field, Discriminator
from pydantic.alias_generators import to_camel

from common_models.user_models import User
from abc import ABC, abstractmethod


class NotificationContext(str, enum.Enum):
    CHECKOUT = "CHECKOUT"
    # Other contexts in which we may receive notifications can be added here


# HelloAsso doesn't allow item management for checkouts, so we manage them ourselves by storing them in checkouts metadata
type CheckoutItemId = str


class CheckoutItemInfo(ABC):
    @property
    @abstractmethod
    def price(self) -> int:
        """Price of the item in cents"""
        ...

    @property
    @abstractmethod
    def display_name(self) -> str:
        """Display name of the item"""
        ...

    # We DON'T store purchase state anywhere. Purchases are simply "applied" once we receive the webhook from helloasso.
    #  So we need to define 1. if the user can currently purchase the item
    #                       2. how to apply the purchase when we receive the webhook
    #                       3. if the purchase has taken effect (so we can confirm the user that their purchase was successful)
    @abstractmethod
    async def can_user_buy(self, user: User) -> bool:
        """Can the user currently buy this item ?"""
        ...

    @abstractmethod
    async def apply_purchase(self, user: User, db: AsyncIOMotorDatabase) -> None:
        """Apply the purchase to the user"""
        ...

    @abstractmethod
    async def is_purchase_applied(self, user: User, db: AsyncIOMotorDatabase) -> bool:
        """Has the purchase taken effect for the user ?"""
        ...


# cf HelloAsso doc
class PaymentState(str, Enum):
    PENDING = "Pending"
    AUTHORIZED = "Authorized"
    REFUSED = "Refused"
    UNKNOWN = "Unknown"
    REGISTERED = "Registered"
    ERROR = "Error"
    REFUNDED = "Refunded"
    REFUNDING = "Refunding"
    WAITING = "Waiting"
    CANCELED = "Canceled"
    CONTESTED = "Contested"
    WAITINGBANKVALIDATION = "WaitingBankValidation"
    WAITINGBANKWITHDRAW = "WaitingBankWithdraw"
    ABANDONED = "Abandoned"
    WAITINGAUTHENTICATION = "WaitingAuthentication"
    AUTHORIZEDPREPROD = "AuthorizedPreprod"
    CORRECTED = "Corrected"
    DELETED = "Deleted"
    INCONSISTENT = "Inconsistent"
    NODONATION = "NoDonation"
    INIT = "Init"


# We define metadata models for different notification contexts. So the same metadata model can be used in
#  different notification types. E.g. Paying a checkout generates two notifications (Payment & Order) but we want the
#  same metadata in both (they provide from the same action, so they have the same context)

# To avoid failing validation when receiving metadata not in the format sadh expects (i.e. outside of sadh's scope),
#  the sadh specific metadata models are defined separately (SadhNotificationMetadata) and then used in a wrapper model
#  (SadhNotificationMetadata), in an optional field "sadh_metadata"


class BaseSadhNotificationMetadata(RezelBaseModel, ABC):
    issued_at: int = Field(default_factory=lambda: int(time.time()))


class CheckoutMetadata(BaseSadhNotificationMetadata):
    context: Literal[NotificationContext.CHECKOUT] = NotificationContext.CHECKOUT
    checkout_item_ids: list[CheckoutItemId]
    user_id: str
    return_url: str


SadhNotificationMetadata = CheckoutMetadata  # | OtherMetadataTypes


class NotificationMetadata(RezelBaseModel):
    sadh_metadata: SadhNotificationMetadata | None = Field(
        None,
        discriminator="context",  # The type of the sadh_metadata field is indicated by the "context" field
    )  # the field is None if the notification was not generated by sadh (i.e. no sadh_metadata field)
    sadh_metadata_sig: str | None = (
        None  # HMAC-SHA256 signature of the sadh_metadata field
    )


def check_sadh_metadata_signature(
    metadata: NotificationMetadata | None,
    secret: str,
) -> bool:
    if (
        metadata is None
        or metadata.sadh_metadata is None
        or metadata.sadh_metadata_sig is None
    ):
        return False

    canonical_json = json.dumps(
        metadata.sadh_metadata.model_dump(),
        separators=(",", ":"),
        sort_keys=True,
    )

    computed_sig = hmac.new(
        key=secret.encode(),
        msg=canonical_json.encode(),
        digestmod=hashlib.sha256,
    ).digest()

    provided_sig = urlsafe_b64decode(metadata.sadh_metadata_sig)

    # Compare the computed signature with the provided signature
    return hmac.compare_digest(computed_sig, provided_sig)


def sign_sadh_metadata(
    sadh_metadata: SadhNotificationMetadata,
    secret: str,
) -> NotificationMetadata:
    canonical_json = json.dumps(
        sadh_metadata.model_dump(),
        separators=(",", ":"),
        sort_keys=True,
    ).encode("utf-8")

    sig = hmac.new(
        secret.encode("utf-8"),
        canonical_json,
        hashlib.sha256,
    ).digest()
    sig_b64 = urlsafe_b64encode(sig).decode("utf-8")

    return NotificationMetadata(sadh_metadata=sadh_metadata, sadh_metadata_sig=sig_b64)


# HelloAsso field naming convention is camelCase
class CamelCaseModel(RezelBaseModel, ABC):
    model_config = ConfigDict(
        alias_generator=to_camel, populate_by_name=True, from_attributes=True
    )


class NotificationType(str, Enum):
    PAYMENT = "Payment"
    ORDER = "Order"
    FORM = "Form"
    ORGANIZATION = "Organization"


class PaymentNotificationData(CamelCaseModel):
    state: PaymentState


class PaymentNotification(RezelBaseModel):
    eventType: Literal[NotificationType.PAYMENT] = NotificationType.PAYMENT
    data: PaymentNotificationData
    metadata: NotificationMetadata | None = None


# Incomplete types, unused and ignored for now, specified to avoid failing validation
class OrderNotification(RezelBaseModel):
    eventType: Literal[NotificationType.ORDER] = NotificationType.ORDER
    metadata: NotificationMetadata | None = None


class FormNotification(RezelBaseModel):
    eventType: Literal[NotificationType.FORM] = NotificationType.FORM
    metadata: NotificationMetadata | None = None


class OrganizationNotification(RezelBaseModel):
    eventType: Literal[NotificationType.ORGANIZATION] = NotificationType.ORGANIZATION
    metadata: NotificationMetadata | None = None


Notification = Annotated[
    PaymentNotification
    | OrderNotification
    | FormNotification
    | OrganizationNotification,
    Discriminator(discriminator="eventType"),
]

# Disclaimer, the following models are incomplete and only the fields currently used by sadh are defined
#  See https://dev.helloasso.com/reference for the full helloasso documentation


class CheckoutPayment(CamelCaseModel):
    id: int
    state: PaymentState


class Payer(CamelCaseModel):
    email: str | None = None
    address: str | None = None
    city: str | None = None
    zip_code: str | None = None
    country: str | None = None
    company: str | None = None
    date_of_birth: datetime | None = None
    first_name: str | None = None
    last_name: str | None = None


class CheckoutOrder(CamelCaseModel):
    id: int
    payments: list[CheckoutPayment] = []


class InitCheckoutBody(CamelCaseModel):
    total_amount: int
    initial_amount: int
    item_name: str
    back_url: str
    error_url: str
    return_url: str
    contains_donation: bool
    payer: Payer
    metadata: NotificationMetadata | None = None


class InitCheckoutResponse(CamelCaseModel):
    id: int
    redirect_url: str | None = None


class CheckoutIntentResponse(CamelCaseModel):
    metadata: NotificationMetadata | None = None
    id: int | None = None
    redirect_url: str | None = None
    order: CheckoutOrder
